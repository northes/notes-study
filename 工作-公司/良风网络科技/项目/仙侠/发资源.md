## 新系统

采用新的 `ResourceCtrl` 系统

添加 ResourceOp 

`resource_op.enum.go`

```go
type sResourceCtrlOp = struct{
...
// 循环奖励  
ScoreRotate sResourceCtrlOp_ScoreRotate
}

type sResourceCtrlOp_ScoreRotate struct {  
   Reward ResourceCtrlOpID  
}  
  
func (this sResourceCtrlOp_ScoreRotate) Ranges() []struct{ Min, Max int64 } {  
   return []struct{ Min, Max int64 }{  
      {Min: 102301, Max: 102400},  
   }  
}  
  
var vResourceCtrlOp_ScoreRotate = sResourceCtrlOp_ScoreRotate{  
   Reward: 102301,  
}
```

`operating_ctrl.score_rotate.cache.go`

```go
// 发奖
err = SharedResourceManager.Run(ctx, &ResourceManagerRequest{  
   Player: player,  
   OpID:   enum.ResourceCtrlOp.ScoreRotate.Reward,  
   Rate:   enum.ResourceDefaultRate.Reward,  
   //ResData:      nil,   // 原计划用于兼容老系统，后来发现用不上，已不用
   CommonReward: rewards,  
}, nil)  
if err != nil {  
   return err  
}
```

> SharedResourceManager.Run 中会检查资源是否够扣，不够扣除将返回 err

> beforeCommit 函数通常用于扣除资源。多用在购买-发奖的场景。执行顺序为 先执行`beforeCommit` 函数，再执行 &ResourceManagerRequest{} 的部分。如果用不到，允许传 nil

## 老系统

```go
// 前置检查
if !SharedRewardConfig.CanRewardByList(ctx, player, rewards, 1) {
		return errors.NewNotFoundf(
			"[%T].%s 循环奖励(Round:%d,Index:%d)发放奖励前置检查失败 %+v",
			this,
			player,
			round,
			index,
			convert.MustJsonString(rewards),
		).Err()
	}

// 实际发奖
SharedRewardConfig.AddRewardByList(ctx, player, rewards, 1, enum.CommonRewardOp.OperatingScoreRotateReward)
```