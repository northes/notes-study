# 简介
## Hello World

```html
<script>
	let name = 'world';
</script>

<h1>Hello {name}!</h1>
```

应用程序应由一个或多个组件（components）构成。以 `.svelte` 为后缀。

通过花括号引用变量。同时花括号内我们也可以放置 JS 代码

```html
<!--转大写-->
<h1>Hello {name.toUpperCase()}!</h1>
```

## 动态属性

```html
<script>
	let src = 'tutorial/image.gif';
	let name = 'Rick Astley';
</script>

<img src={src} alt="{name} dances.">
```

可以通过花括号绑定属性

属性与变量同名(均为src)时，可简写

```html
<img {src} alt="{name} dances.">
```

## CSS 样式

```html
<style>
	p {
		color: purple;
		font-family: 'Comic Sans MS', cursive;
		font-size: 2em;
	}
</style>

<p>This is a paragraph.</p>
```

这些 CSS 样式规则的作用域将被限定在当前组件中。不会更改其他地方的`<p>`元素


## 嵌套组件

`App.svelte`

```html
<style>
	p {
		color: purple;
		font-family: 'Comic Sans MS', cursive;
		font-size: 2em;
	}
</style>

<script>
	import Nested from './Nested.svelte';
</script>

<p>This is a paragraph.</p>
<Nested/>
```

> `App.svelte` 中定义的样式只会影响 `App.svelte` ，不影响 `Nested.svelte`  

`Nested.svelte`

```html
<p>This is another paragraph.</p>
```

## HTML 标签

将内容渲染为 HTML，通过在花括号内加 `{@html ...}`，否则将会将内容做清理，并以纯文本字符串的形式展示

```html
<script>
	let string = `this string contains some <strong>HTML!!!</strong>`;
</script>

<p>{@html string}</p>
```

> 需注意 XSS 攻击

# 反应能力（_reactivity_）

## 赋值

```html
<script>
    let count = 0;

    function handlerClick() {
        count += 1
    }
</script>

<button on:click={handlerClick}>
    Clicked {count} {count === 1 ? 'time' : 'times'}
</button>
```

> 变量发生变化会实时触发更新，保持同步

## 声明

反应式声明（reactive declarations）

```html
<script>
    let count = 0;
    $: doubled = count * 2;

    function handleClick() {
        count += 1;
    }
</script>

<button on:click={handleClick}>
    Clicked {count} {count === 1 ? 'time' : 'times'}
</button>

<p>
    {count} double is {doubled}
</p>
```

## 语句

不仅能对变量进行反应式，语句、代码块同样可以

```html
<script>
    let count = 0;
    $: doubled = count * 2;

    function handleClick() {
        count += 1;
    }

    // 对语句进行反应式
    $: console.log(`this count is ${count}`);

    // 对代码块进行反应式
    $: {
        console.log(`block this count is ${count}`)
        alert(`I SAID THE COUNT IS ${count}`)
    }

    // 对 if 进行反应式
    $: if (count >= 10){
        alert(`count is dangerously high!`);
        count = 9
    }
</script>

<button on:click={handleClick}>
    Clicked {count} {count === 1 ? 'time' : 'times'}
</button>

<p>
    {count} double is {doubled}
</p>
```

## 更新数组和对象

由于反应性是由赋值语句触发的，因此使用数组或者 `push` 、`splice` 之类的方法就不会触发自动更新

`pop` `shift` `unshift` `splice` 的方法也可以用类似的模式来替换

### 不能触发更新

```html
<script>
    let numbers = [1, 2, 3, 4];

    function addNumber() {
        numbers.push(numbers.length + 1)
    }

    $: sum = numbers.reduce((t, n) => t + n, 0)
</script>

<p>{numbers.join('+')} = {sum}</p>

<button on:click={addNumber}>
    Add a number
</button>
```

### 使用多余的赋值语句触发更新

```html
<script>
    function addNumber() {
        numbers.push(numbers.length + 1)
        // 使用多余的赋值语句触发更新
        numbers = numbers
    }
</script>
```

### 使用重新赋值触发更新

```html
<script>
    function addNumber() {
        numbers = [...numbers, numbers.length + 1];
    }
</script>
```

### 通过更新数组或对象的属性触发更新

```html
<script>
    function addNumber() {
        numbers[numbers.length] = numbers.length + 1
    }
</script>
```

# 属性

## Props

组件间传递参数

由子组件暴露变量，从父组件传入数据，由子组件进行渲染

`App.svelte`

```html
<script lang="ts">
  import Learn from "./lib/Learn.svelte";
</script>

<main>
    <Learn answer="65"/>
</main>
```

`Learn.svelte`

```html
<script>
    export let answer;
</script>

<p>
    The Answer is {answer}!
</p>
```

## 默认值

父组件未传参的时候，渲染默认值

```html
<script>
    export let answer = 666;
</script>

<p>
    The Answer is {answer}!
</p>
```

## 属性传递

`Learn.svelte`

```html
<script>
    export let name;
    export let version;
    export let speed;
    export let website;
</script>

<p>
    The <code>{name}</code> package is {speed} fast.
    Download version {version} from <a href="xxx">npm</a>
    and <a href="{website}">learn more here</a>
</p>
```

`App.svelte`

```html
<script lang="ts">
  import Learn from "./lib/Learn.svelte";

  const pkg = {
      name: 'svelte',
      version: 3,
      speed: 'blazing',
      website: 'https://svelte.dev'
  }
</script>

<main>
    <!--每个参数单独传参-->
    <Learn name={pkg.name} version={pkg.version} speed={pkg.speed} website={pkg.website}/>
    <!--使用...语法将他们 spread(传播) 到一个组件上-->
    <Learn {...pkg}/>
</main>
```

## 未声明的属性

使用 `$$props` 获取

一般不建议这样做，因为 Svelte 很难进行优化

```html
<script>
    // export let name;
</script>

<p>
    <code>{$$props.name}</code>
</p>
```

# 逻辑渲染

## if

```html
<script>
    import {Button} from "@svelteuidev/core";
    const userInfo = {
        loggedIn: true
    }
    function toggle(){
        userInfo.loggedIn = !userInfo.loggedIn
    }
</script>

{#if userInfo.loggedIn}
    <Button on:click={toggle}>
        Log out
    </Button>
{/if}

{#if !userInfo.loggedIn}
    <Button on:click={toggle}>
        Log in
    </Button>
{/if}

User login status: {userInfo.loggedIn}
```

## else

```html
{#if userInfo.loggedIn}
    <Button on:click={toggle}>
        Log out
    </Button>
{:else}
    <Button on:click={toggle}>
        Log in
    </Button>
{/if}
```

## else if

```html
<script>
    let x = 0
    function add(){
        x++
    }
</script>

{#if x > 10}
    <p>{x} is greater than 10</p>
{:else if 5 > x}
    <p>{x} is less than 5</p>
{:else }
    <p>{x} is between 5 and 10</p>
{/if}

<button on:click={add}>add</button>
```

## each

```html
<script>
	let cats = [
		{ id: 'J---aiyznGQ', name: 'Keyboard Cat' },
		{ id: 'z_AbfPXTKms', name: 'Maru' },
		{ id: 'OUtn3pvWmpg', name: 'Henri The Existential Cat' }
	];
</script>

<h1>The Famous Cats of YouTube</h1>

<ul>
	{#each cats as { id, name }, i}
		<li><a target="_blank" href="https://www.youtube.com/watch?v={id}">
			{i + 1}: id:{id} name: {name}
		</a></li>
	{/each}
</ul>
```

> i 为index，可省略
> {id,name} 为解构后的字段

## 为 each 块添加 key 值

`App.svelte`

```html
<script>
    import Thing from './Thing.svelte';

    let things = [
        { id: 1, color: '#0d0887' },
        { id: 2, color: '#6a00a8' },
        { id: 3, color: '#b12a90' },
        { id: 4, color: '#e16462' },
        { id: 5, color: '#fca636' }
    ];

    function handleClick() {
        things = things.slice(1);
    }

    $: console.log(things)
</script>

<button on:click={handleClick}>
    Remove first thing
</button>

{#each things as thing}
    <Thing current={thing.color}/>
{/each}
```

`Thing.svelte`

```html
<script>
    // `current` is updated whenever the prop value changes...
    export let current;

    // ...but `initial` is fixed upon initialisation
    const initial = current;
</script>

<p>
    <span style="background-color: {initial}">initial</span>
    <span style="background-color: {current}">current</span>
</p>

<style>
    span {
        display: inline-block;
        padding: 0.2em 0.5em;
        margin: 0 0.2em 0.2em 0;
        width: 4em;
        text-align: center;
        border-radius: 0.2em;
        color: white;
    }
</style>
```

## 