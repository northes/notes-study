# 简介
## Hello World

```html
<script>
	let name = 'world';
</script>

<h1>Hello {name}!</h1>
```

应用程序应由一个或多个组件（components）构成。以 `.svelte` 为后缀。

通过花括号引用变量。同时花括号内我们也可以放置 JS 代码

```html
<!--转大写-->
<h1>Hello {name.toUpperCase()}!</h1>
```

## 动态属性

```html
<script>
	let src = 'tutorial/image.gif';
	let name = 'Rick Astley';
</script>

<img src={src} alt="{name} dances.">
```

可以通过花括号绑定属性

属性与变量同名(均为src)时，可简写

```html
<img {src} alt="{name} dances.">
```

## CSS 样式

```html
<style>
	p {
		color: purple;
		font-family: 'Comic Sans MS', cursive;
		font-size: 2em;
	}
</style>

<p>This is a paragraph.</p>
```

这些 CSS 样式规则的作用域将被限定在当前组件中。不会更改其他地方的`<p>`元素


## 嵌套组件

`App.svelte`

```html
<style>
	p {
		color: purple;
		font-family: 'Comic Sans MS', cursive;
		font-size: 2em;
	}
</style>

<script>
	import Nested from './Nested.svelte';
</script>

<p>This is a paragraph.</p>
<Nested/>
```

> `App.svelte` 中定义的样式只会影响 `App.svelte` ，不影响 `Nested.svelte`  

`Nested.svelte`

```html
<p>This is another paragraph.</p>
```

## HTML 标签

将内容渲染为 HTML，通过在花括号内加 `{@html ...}`，否则将会将内容做清理，并以纯文本字符串的形式展示

```html
<script>
	let string = `this string contains some <strong>HTML!!!</strong>`;
</script>

<p>{@html string}</p>
```

> 需注意 XSS 攻击

# 反应能力（_reactivity_）

## 赋值

```html
<script>
    let count = 0;

    function handlerClick() {
        count += 1
    }
</script>

<button on:click={handlerClick}>
    Clicked {count} {count === 1 ? 'time' : 'times'}
</button>
```

> 变量发生变化会实时触发更新，保持同步

## 声明

反应式声明（reactive declarations）

```html
<script>
    let count = 0;
    $: doubled = count * 2;

    function handleClick() {
        count += 1;
    }
</script>

<button on:click={handleClick}>
    Clicked {count} {count === 1 ? 'time' : 'times'}
</button>

<p>
    {count} double is {doubled}
</p>
```

## 语句

不仅能对变量进行反应式，语句、代码块同样可以

```html
<script>
    let count = 0;
    $: doubled = count * 2;

    function handleClick() {
        count += 1;
    }

    // 对语句进行反应式
    $: console.log(`this count is ${count}`);

    // 对代码块进行反应式
    $: {
        console.log(`block this count is ${count}`)
        alert(`I SAID THE COUNT IS ${count}`)
    }

    // 对 if 进行反应式
    $: if (count >= 10){
        alert(`count is dangerously high!`);
        count = 9
    }
</script>

<button on:click={handleClick}>
    Clicked {count} {count === 1 ? 'time' : 'times'}
</button>

<p>
    {count} double is {doubled}
</p>
```

## 更新数组和对象

由于反应性是由赋值语句触发的，因此使用数组或者 `push` 、`splice` 之类的方法就不会触发自动更新

`pop` `shift` `unshift` `splice` 的方法也可以用类似的模式来替换

### 不能触发更新

```html
<script>
    let numbers = [1, 2, 3, 4];

    function addNumber() {
        numbers.push(numbers.length + 1)
    }

    $: sum = numbers.reduce((t, n) => t + n, 0)
</script>

<p>{numbers.join('+')} = {sum}</p>

<button on:click={addNumber}>
    Add a number
</button>
```

### 使用多余的赋值语句触发更新

```html
<script>
    function addNumber() {
        numbers.push(numbers.length + 1)
        // 使用多余的赋值语句触发更新
        numbers = numbers
    }
</script>
```

### 使用重新赋值触发更新

```html
<script>
    function addNumber() {
        numbers = [...numbers, numbers.length + 1];
    }
</script>
```

### 通过更新数组或对象的属性触发更新

```html
<script>
    function addNumber() {
        numbers[numbers.length] = numbers.length + 1
    }
</script>
```

# 属性

## Props

组件间传递参数

由子组件暴露变量，从父组件传入数据，由子组件进行渲染

`App.svelte`

```html
<script lang="ts">
  import Learn from "./lib/Learn.svelte";
</script>

<main>
    <Learn answer="65"/>
</main>
```

`Learn.svelte`

```html
<script>
    export let answer;
</script>

<p>
    The Answer is {answer}!
</p>
```

## 默认值

父组件未传参的时候，渲染默认值

```html
<script>
    export let answer = 666;
</script>

<p>
    The Answer is {answer}!
</p>
```

## 属性传递

`Learn.svelte`

```html
<script>
    export let name;
    export let version;
    export let speed;
    export let website;
</script>

<p>
    The <code>{name}</code> package is {speed} fast.
    Download version {version} from <a href="xxx">npm</a>
    and <a href="{website}">learn more here</a>
</p>
```

`App.svelte`

```html
<script lang="ts">
  import Learn from "./lib/Learn.svelte";

  const pkg = {
      name: 'svelte',
      version: 3,
      speed: 'blazing',
      website: 'https://svelte.dev'
  }
</script>

<main>
    <!--每个参数单独传参-->
    <Learn name={pkg.name} version={pkg.version} speed={pkg.speed} website={pkg.website}/>
    <!--使用...语法将他们 spread(传播) 到一个组件上-->
    <Learn {...pkg}/>
</main>
```

## 未声明的属性

使用 `$$props` 获取

一般不建议这样做，因为 Svelte 很难进行优化

```html
<script>
    // export let name;
</script>

<p>
    <code>{$$props.name}</code>
</p>
```

# 逻辑渲染

## if

```html
<script>
    import {Button} from "@svelteuidev/core";
    const userInfo = {
        loggedIn: true
    }
    function toggle(){
        userInfo.loggedIn = !userInfo.loggedIn
    }
</script>

{#if userInfo.loggedIn}
    <Button on:click={toggle}>
        Log out
    </Button>
{/if}

{#if !userInfo.loggedIn}
    <Button on:click={toggle}>
        Log in
    </Button>
{/if}

User login status: {userInfo.loggedIn}
```

## else

```html
{#if userInfo.loggedIn}
    <Button on:click={toggle}>
        Log out
    </Button>
{:else}
    <Button on:click={toggle}>
        Log in
    </Button>
{/if}
```

## else if

```html
<script>
    let x = 0
    function add(){
        x++
    }
</script>

{#if x > 10}
    <p>{x} is greater than 10</p>
{:else if 5 > x}
    <p>{x} is less than 5</p>
{:else }
    <p>{x} is between 5 and 10</p>
{/if}

<button on:click={add}>add</button>
```

## each

```html
<script>
	let cats = [
		{ id: 'J---aiyznGQ', name: 'Keyboard Cat' },
		{ id: 'z_AbfPXTKms', name: 'Maru' },
		{ id: 'OUtn3pvWmpg', name: 'Henri The Existential Cat' }
	];
</script>

<h1>The Famous Cats of YouTube</h1>

<ul>
	{#each cats as { id, name }, i}
		<li><a target="_blank" href="https://www.youtube.com/watch?v={id}">
			{i + 1}: id:{id} name: {name}
		</a></li>
	{/each}
</ul>
```

> i 为index，可省略
> {id,name} 为解构后的字段

## 为 each 块添加 key 值

`App.svelte`

```html
<script>
    import Thing from './Thing.svelte';

    let things = [
        { id: 1, color: '#0d0887' },
        { id: 2, color: '#6a00a8' },
        { id: 3, color: '#b12a90' },
        { id: 4, color: '#e16462' },
        { id: 5, color: '#fca636' }
    ];

    function handleClick() {
        things = things.slice(1);
    }

    $: console.log(things)
</script>

<button on:click={handleClick}>
    Remove first thing
</button>

{#each things as thing}
    <Thing current={thing.color}/>
{/each}
```

`Thing.svelte`

```html
<script>
    // `current` is updated whenever the prop value changes...
    export let current;

    // ...but `initial` is fixed upon initialisation
    const initial = current;
</script>

<p>
    <span style="background-color: {initial}">initial</span>
    <span style="background-color: {current}">current</span>
</p>

<style>
    span {
        display: inline-block;
        padding: 0.2em 0.5em;
        margin: 0 0.2em 0.2em 0;
        width: 4em;
        text-align: center;
        border-radius: 0.2em;
        color: white;
    }
</style>
```

## Await 块

用于异步数据的处理

```html
<script>
	let promise = getRandomNumber();

	async function getRandomNumber() {
		const res = await fetch(`tutorial/random-number`);
		const text = await res.text();

		if (res.ok) {
			return text;
		} else {
			throw new Error(text);
		}
	}

	function handleClick() {
		promise = getRandomNumber();
	}
</script>

<button on:click={handleClick}>
	generate random number
</button>

{#await promise}
	<p>...waiting</p>
{:then number}
	<p>The number is {number}</p>
{:catch error}
	<p style="color: red">{error.message}</p>
{/await}
```

# 事件

## DOM 事件

```html
<script>
	let m = { x: 0, y: 0 };

	function handleMousemove(event) {
		m.x = event.clientX;
		m.y = event.clientY;
	}
</script>

<div on:mousemove={handleMousemove}>
	The mouse position is {m.x} x {m.y}
</div>

<style>
	div { width: 100%; height: 100%; }
</style>
```

## 内联方法

```html
<script>
	let m = { x: 0, y: 0 };

	function handleMousemove(event) {
		m.x = event.clientX;
		m.y = event.clientY;
	}
</script>

<div on:mousemove="{e => m = {x: e.clientX, y: e.clientY}}">
	The mouse position is {m.x} x {m.y}
</div>

<style>
	div { width: 100%; height: 100%; }
</style>
```

> 由于编译器最终会进行优化，因此在 svelte 中，内联方法不会造成行刑损耗


## 修饰符

通过修饰符定义事件的行为


```html
<script>
	function handleClick() {
		alert('clicked')
	}
</script>
<!--once: 只会触发一次-->
<button on:click|once={handleClick}>
	Click me
</button>
```

- preventDefault：在运行处理程序前调用
- stopPropagation：调用 `event.stopPropagation()` 防止事件到达下一个元素
- passive：改进了触摸/滚轮事件的滚动性能
- nonpassive：明确设置 `passive:false`
- capture：在 *捕获* 阶段而不是 *冒泡* 阶段触发处理程序
- once：仅运行一次
- self：只有当 `event.target` 是自身的时候才触发
- trusted：仅在 `event.isTrusted` 时触发。即事件是由用户触发的

可以多个一起使用 `on:click|once|capture={...}`


## 组件事件

组件事件向上传递

```html
<script>
	import Inner from './Inner.svelte';

	function handleMessage(event) {
		alert(event.detail.text);
	}
</script>

<Inner on:message={handleMessage}/>
```

```html
<script>
	import {createEventDispatcher} from 'svelte';
	
	const dispatch = createEventDispatcher();
	
	function sayHello() {
		dispatch('message',{
			text: 'Hellosss!'
		})
	}
</script>

<button on:click={sayHello}>
	Click to say hello
</button>
```

## 事件转发

与 DOM 事件不同，组件事件不会 *冒泡*，如果想要在某个深层嵌套的组件上监听事件，则中间组件必须 *转发* 该事件。

当然我们可以在中间的组件中引入 `createEventDispatcher` 来接收后进行转发

组件层级关系

App.svelte - Outer.svelte - Inner.svelte

`Outer.svelte`

```html
<script>
	import Inner from './Inner.svelte';
	import { createEventDispatcher } from 'svelte';

	const dispatch = createEventDispatcher();

	function forward(event) {
		dispatch('message', event.detail);
	}
</script>

<Inner on:message={forward}/>
```

这样写似乎有些臃肿，Svelte 提供了一个简写属性 `on:message` 。 `message` 没有赋予特定值的情况下意味着转发所有的 `message` 事件

```html
<script>
	import Inner from './Inner.svelte'
</script>

<Inner on:message>
```

## DOM 事件转发

简言之，子组件触发事件，但是调用的父组件的函数

`CustomButton.svelte`

```html
<style>
	button {
		height: 4rem;
		width: 8rem;
		background-color: #aaa;
		border-color: #f1c40f;
		color: #f1c40f;
		font-size: 1.25rem;
		background-image: linear-gradient(45deg, #f1c40f 50%, transparent 50%);
		background-position: 100%;
		background-size: 400%;
		transition: background 300ms ease-in-out;
	}
	button:hover {
		background-position: 0;
		color: #aaa;
	}
</style>

<button on:click>
	Click me
</button>
```

`App.svelte`

```html
<script>
	import CustomButton from './CustomButton.svelte';

	function handleClick() {
		alert('clicked');
	}
</script>

<CustomButton on:click={handleClick}/>
```

# 绑定

## Text Input

```html
<script>
	let name = 'world';
</script>

<input bind:value={name}>

<h1>Hello {name}!</h1>
```

## 数字

在 DOM 中，无论是数字还是字符串，都会强制转换为字符串，统一使用 `bind:value` 即可

```html
<script>
	let a = 1;
	let b = 2;
</script>

<label>
	<input type=number bind:value={a} min=0 max=10>
	<input type=range bind:value={a} min=0 max=10>
</label>

<label>
	<input type=number bind:value={b} min=0 max=10>
	<input type=range bind:value={b} min=0 max=10>
</label>

<p>{a} + {b} = {a + b}</p>

<style>
	label { display: flex }
	input, p { margin: 6px }
</style>
```

## 复选框

```html
<script>
	let yes = false;
</script>

<label>
	<input type=checkbox bind:checked={yes}>
	Yes! Send me regular email spam
</label>

{#if yes}
	<p>Thank you. We will bombard your inbox and sell your personal details.</p>
{:else}
	<p>You must opt-in to continue. If you're not paying, you're the product.</p>
{/if}

<button disabled={!yes}>
	Subscribe
</button>
```

## 绑定组Input

通过将多个 Input 绑定成组，提高效率

```html
<script>
	let scoops = 1;
	let flavours = ['Mint choc chip'];

	function join(flavours) {
		if (flavours.length === 1) return flavours[0];
		return `${flavours.slice(0, -1).join(', ')} and ${flavours[flavours.length - 1]}`;
	}
	
	let menu = [
	'Cookies and cream',
	'Mint choc chip',
	'Raspberry ripple'
];
</script>

<h2>Size</h2>

<label>
	<input type=radio bind:group={scoops} name="scoops" value={1}>
	One scoop
</label>

<label>
	<input type=radio bind:group={scoops} name="scoops" value={2}>
	Two scoops
</label>

<label>
	<input type=radio bind:group={scoops} name="scoops" value={3}>
	Three scoops
</label>

<h2>Flavours</h2>

{#each menu as flavour}
	<label>
	<input type=checkbox bind:group={flavours} name="flavours" value={flavour}>
	{flavour}
</label>
{/each}

{#if flavours.length === 0}
	<p>Please select at least one flavour</p>
{:else if flavours.length > scoops}
	<p>Can't order more flavours than scoops!</p>
{:else}
	<p>
		You ordered {scoops} {scoops === 1 ? 'scoop' : 'scoops'}
		of {join(flavours)}
	</p>
{/if}
```

## Textarea

```html
<script>
	import { marked } from 'marked';
	let value = `Some words are *italic*, some are **bold**`;
</script>

{@html marked(value)}

<textarea bind:value={value}></textarea>

<style>
	textarea { width: 100%; height: 200px; }
</style>
```

## Select

```html
<script>
	let questions = [
		{ id: 1, text: `Where did you go to school?` },
		{ id: 2, text: `What is your mother's name?` },
		{ id: 3, text: `What is another personal fact that an attacker could easily find with Google?` }
	];

	let selected;

	let answer = '';

	function handleSubmit() {
		alert(`answered question ${selected.id} (${selected.text}) with "${answer}"`);
	}
</script>

<h2>Insecurity questions</h2>

<form on:submit|preventDefault={handleSubmit}>
	<select bind:value={selected} on:change="{() => answer = ''}">
		{#each questions as question}
			<option value={question}>
				{question.text}
			</option>
		{/each}
	</select>

	<input bind:value={answer}>

	<button disabled={!answer} type=submit>
		Submit
	</button>
</form>

<p>selected question {selected ? selected.id : '[waiting...]'}</p>

<style>
	input {
		display: block;
		width: 500px;
		max-width: 100%;
	}
</style>
```

## Select 多选

设置 `multiple` 后，将支持多选

```html
<script>
	let scoops = 1;
	let flavours = ['Mint choc chip'];

	let menu = [
		'Cookies and cream',
		'Mint choc chip',
		'Raspberry ripple'
	];

	function join(flavours) {
		if (flavours.length === 1) return flavours[0];
		return `${flavours.slice(0, -1).join(', ')} and ${flavours[flavours.length - 1]}`;
	}
</script>

<h2>Size</h2>

<label>
	<input type=radio bind:group={scoops} value={1}>
	One scoop
</label>

<label>
	<input type=radio bind:group={scoops} value={2}>
	Two scoops
</label>

<label>
	<input type=radio bind:group={scoops} value={3}>
	Three scoops
</label>

<h2>Flavours</h2>

<select multiple bind:value={flavours}>
	{#each menu as flavour}
		<option value={flavour}>
			{flavour}
		</option>
	{/each}
</select>

{#if flavours.length === 0}
	<p>Please select at least one flavour</p>
{:else if flavours.length > scoops}
	<p>Can't order more flavours than scoops!</p>
{:else}
	<p>
		You ordered {scoops} {scoops === 1 ? 'scoop' : 'scoops'}
		of {join(flavours)}
	</p>
{/if}

```

## 可编辑块

`contenteditable` 指示块内的内容可编辑，通过 `bind:innerHTML` 进行绑定，可选的值还有

- innerHTML：插入 HTML，
- innerText：插入文本
- textContent：类似插入 HTML，不会进行渲染

[区别](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent#differences_from_innertext)

```html
<script>
	let html = '<p>Write some text!</p>';
</script>

<div contenteditable="true" bind:innerHTML={html}></div>

<pre>{html}</pre>

<style>
	[contenteditable] {
		padding: 0.5em;
		border: 1px solid #eee;
		border-radius: 4px;
	}
</style>
```

## 绑定 Each

可以绑定 `each` 出来的内容。需注意，此举可能会导致原数组内容改变。由于与 Input 绑定，任何意外的修改都会导致数组内容发生变动。

```html
<script>
	let todos = [
		{ done: false, text: 'finish Svelte tutorial' },
		{ done: false, text: 'build an app' },
		{ done: false, text: 'world domination' }
	];

	function add() {
		todos = todos.concat({ done: false, text: '' });
	}

	function clear() {
		todos = todos.filter(t => !t.done);
	}

	$: remaining = todos.filter(t => !t.done).length;
</script>

<h1>Todos</h1>

{#each todos as todo}
	<div class:done={todo.done}>
		<input
			type=checkbox
			bind:checked={todo.done}
		>

		<input
			placeholder="What needs to be done?"
			bind:value={todo.text}
		>
	</div>
{/each}

<p>{remaining} remaining</p>

<button on:click={add}>
	Add new
</button>

<button on:click={clear}>
	Clear completed
</button>

<style>
	.done {
		opacity: 0.4;
	}
</style>
```

## 绑定媒体 Video 、Audio

只读属性：

- duration：
- buffered：
- seekable：
- played：
- seeking：
- ended：

双向绑定属性：

- currentTime：当前的时间进度，秒
- playbackRate：播放速率，1 为正常
- paused：暂停，bool
- volume：音量大小，0~1
- muted：静音，bool

## 绑定块元素属性

```html
<div bind:clientWidth={w} bind:clientHeight={h}>
	<span style="font-size: {size}px">{text}</span>
</div>
```

均为只读属性，获取块元素的长宽

- clientWidth
- clientHeight
- offsetWidth
- offsetHeight

## this

```html
<script>
	import { onMount } from 'svelte';

	let canvas;

	onMount(() => {
		const ctx = canvas.getContext('2d');
		let frame = requestAnimationFrame(loop);

		function loop(t) {
			frame = requestAnimationFrame(loop);

			const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

			for (let p = 0; p < imageData.data.length; p += 4) {
				const i = p / 4;
				const x = i % canvas.width;
				const y = i / canvas.width >>> 0;

				const r = 64 + (128 * x / canvas.width) + (64 * Math.sin(t / 1000));
				const g = 64 + (128 * y / canvas.height) + (64 * Math.cos(t / 1000));
				const b = 128;

				imageData.data[p + 0] = r;
				imageData.data[p + 1] = g;
				imageData.data[p + 2] = b;
				imageData.data[p + 3] = 255;
			}

			ctx.putImageData(imageData, 0, 0);
		}

		return () => {
			cancelAnimationFrame(frame);
		};
	});
</script>

<canvas
	bind:this={canvas}
	width={32}
	height={32}
></canvas>

<style>
	canvas {
		width: 100%;
		height: 100%;
		background-color: #666;
		-webkit-mask: url(/svelte-logo-mask.svg) 50% 50% no-repeat;
		mask: url(/svelte-logo-mask.svg) 50% 50% no-repeat;
	}
</style>

```

## 绑定组件的值

`Keypad.svelte`

```html
<script>
	import { createEventDispatcher } from 'svelte';

	export let value = '';

	const dispatch = createEventDispatcher();

	const select = num => () => value += num;
	const clear  = () => value = '';
	const submit = () => dispatch('submit');
</script>

<div class="keypad">
	<button on:click={select(1)}>1</button>
	<button on:click={select(2)}>2</button>
	<button on:click={select(3)}>3</button>
	<button on:click={select(4)}>4</button>
	<button on:click={select(5)}>5</button>
	<button on:click={select(6)}>6</button>
	<button on:click={select(7)}>7</button>
	<button on:click={select(8)}>8</button>
	<button on:click={select(9)}>9</button>

	<button disabled={!value} on:click={clear}>clear</button>
	<button on:click={select(0)}>0</button>
	<button disabled={!value} on:click={submit}>submit</button>
</div>

<style>
	.keypad {
		display: grid;
		grid-template-columns: repeat(3, 5em);
		grid-template-rows: repeat(4, 3em);
		grid-gap: 0.5em
	}

	button {
		margin: 0
	}
</style>
```

`App.svelte`

```html
<script>
	import Keypad from './Keypad.svelte';

	let pin;
	$: view = pin ? pin.replace(/\d(?!$)/g, '•') : 'enter your pin';

	function handleSubmit() {
		alert(`submitted ${pin}`);
	}
</script>

<h1 style="color: {pin ? '#333' : '#ccc'}">{view}</h1>

<Keypad on:submit={handleSubmit} bind:value={pin}/>
```