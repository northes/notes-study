# 简介
## Hello World

```html
<script>
	let name = 'world';
</script>

<h1>Hello {name}!</h1>
```

应用程序应由一个或多个组件（components）构成。以 `.svelte` 为后缀。

通过花括号引用变量。同时花括号内我们也可以放置 JS 代码

```html
<!--转大写-->
<h1>Hello {name.toUpperCase()}!</h1>
```

## 动态属性

```html
<script>
	let src = 'tutorial/image.gif';
	let name = 'Rick Astley';
</script>

<img src={src} alt="{name} dances.">
```

可以通过花括号绑定属性

属性与变量同名(均为src)时，可简写

```html
<img {src} alt="{name} dances.">
```

## CSS 样式

```html
<style>
	p {
		color: purple;
		font-family: 'Comic Sans MS', cursive;
		font-size: 2em;
	}
</style>

<p>This is a paragraph.</p>
```

这些 CSS 样式规则的作用域将被限定在当前组件中。不会更改其他地方的`<p>`元素


## 嵌套组件

`App.svelte`

```html
<style>
	p {
		color: purple;
		font-family: 'Comic Sans MS', cursive;
		font-size: 2em;
	}
</style>

<script>
	import Nested from './Nested.svelte';
</script>

<p>This is a paragraph.</p>
<Nested/>
```

> `App.svelte` 中定义的样式只会影响 `App.svelte` ，不影响 `Nested.svelte`  

`Nested.svelte`

```html
<p>This is another paragraph.</p>
```

## HTML 标签

将内容渲染为 HTML，通过在花括号内加 `{@html ...}`，否则将会将内容做清理，并以纯文本字符串的形式展示

```html
<script>
	let string = `this string contains some <strong>HTML!!!</strong>`;
</script>

<p>{@html string}</p>
```

> 需注意 XSS 攻击

# 反应能力（_reactivity_）

## 赋值

```html
<script>
    let count = 0;

    function handlerClick() {
        count += 1
    }
</script>

<button on:click={handlerClick}>
    Clicked {count} {count === 1 ? 'time' : 'times'}
</button>
```

> 变量发生变化会实时触发更新，保持同步

## 声明

反应式声明（reactive declarations）

```html
<script>
    let count = 0;
    $: doubled = count * 2;

    function handleClick() {
        count += 1;
    }
</script>

<button on:click={handleClick}>
    Clicked {count} {count === 1 ? 'time' : 'times'}
</button>

<p>
    {count} double is {doubled}
</p>
```

## 语句

不仅能对变量进行反应式，语句、代码块同样可以

```html
<script>
    let count = 0;
    $: doubled = count * 2;

    function handleClick() {
        count += 1;
    }

    // 对语句进行反应式
    $: console.log(`this count is ${count}`);

    // 对代码块进行反应式
    $: {
        console.log(`block this count is ${count}`)
        alert(`I SAID THE COUNT IS ${count}`)
    }

    // 对 if 进行反应式
    $: if (count >= 10){
        alert(`count is dangerously high!`);
        count = 9
    }
</script>

<button on:click={handleClick}>
    Clicked {count} {count === 1 ? 'time' : 'times'}
</button>

<p>
    {count} double is {doubled}
</p>
```

## 更新数组和对象

由于反应性是由赋值语句触发的，因此使用数组或者 `push` 、`splice` 之类的方法就不会触发自动更新

`pop` `shift` `unshift` `splice` 的方法也可以用类似的模式来替换

### 不能触发更新

```html
<script>
    let numbers = [1, 2, 3, 4];

    function addNumber() {
        numbers.push(numbers.length + 1)
    }

    $: sum = numbers.reduce((t, n) => t + n, 0)
</script>

<p>{numbers.join('+')} = {sum}</p>

<button on:click={addNumber}>
    Add a number
</button>
```

### 使用多余的赋值语句触发更新

```html
<script>
    function addNumber() {
        numbers.push(numbers.length + 1)
        // 使用多余的赋值语句触发更新
        numbers = numbers
    }
</script>
```

### 使用重新赋值触发更新

```html
<script>
    function addNumber() {
        numbers = [...numbers, numbers.length + 1];
    }
</script>
```

### 通过更新数组或对象的属性触发更新

```html
<script>
    function addNumber() {
        numbers[numbers.length] = numbers.length + 1
    }
</script>
```